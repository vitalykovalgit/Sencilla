namespace Sencilla.Messaging.SourceGenerator;

[Generator]
public class MessageDispatcherExtensionGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new CommandClassReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not CommandClassReceiver receiver)
            return;

        // Look for the attribute type
        var attributeSymbol = context.Compilation.GetTypeByMetadataName(typeof(ExtendDispatcherAttribute).FullName!);
        if (attributeSymbol == null)
            return;

        var iMessageDispatcherSymbol = context.Compilation.GetTypeByMetadataName(typeof(IMessageDispatcher).FullName!);
        if (iMessageDispatcherSymbol == null)
            return;

        var commandClasses = new List<CommandClassInfo>();
        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            var semanticModel = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
            if (classSymbol == null)
                continue;

            // Check if class has the attribute
            var hasAttribute = classSymbol.GetAttributes().Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attributeSymbol));
            if (!hasAttribute)
                continue;

            var commandInfo = ExtractCommandInfo(classSymbol, classDeclaration);
            if (commandInfo != null)
                commandClasses.Add(commandInfo);
        }

        if (commandClasses.Any())
        {
            var sourceText = GenerateExtensionClass(commandClasses);
            context.AddSource("MessageDispatcherExtensions.g.cs", SourceText.From(sourceText, Encoding.UTF8));
        }
    }

    private CommandClassInfo? ExtractCommandInfo(INamedTypeSymbol classSymbol, ClassDeclarationSyntax classDeclaration)
    {
        var properties = new List<PropertyInfo>();

        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (member.SetMethod?.DeclaredAccessibility == Accessibility.Public &&
                member.GetMethod?.DeclaredAccessibility == Accessibility.Public)
            {
                // Find the corresponding property declaration in syntax to get default value
                var propertyDeclaration = classDeclaration.Members
                    .OfType<PropertyDeclarationSyntax>()
                    .FirstOrDefault(p => p.Identifier.ValueText == member.Name);

                string? defaultValue = null;
                bool isRequired = false;
                
                if (propertyDeclaration != null)
                {
                    // Check if property has 'required' modifier
                    isRequired = propertyDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.RequiredKeyword));
                    
                    // Get default value from initializer
                    if (propertyDeclaration.Initializer?.Value != null)
                        defaultValue = propertyDeclaration.Initializer.Value.ToString();
                }

                properties.Add(new PropertyInfo
                {
                    Name = member.Name,
                    Type = member.Type.ToDisplayString(),
                    ParameterName = ToCamelCase(member.Name),
                    DefaultValue = defaultValue,
                    IsRequired = isRequired
                });
            }
        }

        if (!properties.Any())
            return null;

        // Get method name from attribute or use class name
        var generateAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(attr => attr.AttributeClass?.Name == "ExtendDispatcherAttribute");
        
        var methodName = generateAttribute?.NamedArguments
            .FirstOrDefault(arg => arg.Key == "Method").Value.Value?.ToString();

        if (string.IsNullOrEmpty(methodName))
        {
            methodName = classSymbol.Name;
            if (methodName.EndsWith("Command"))
                methodName = methodName.Substring(0, methodName.Length - 7);
        }

        return new CommandClassInfo
        {
            ClassName = classSymbol.Name,
            FullTypeName = classSymbol.ToDisplayString(),
            Namespace = classSymbol.ContainingNamespace.ToDisplayString(),
            MethodName = methodName,
            Properties = properties
        };
    }

    private string GenerateExtensionClass(List<CommandClassInfo> commandClasses)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Sencilla.Messaging;");
        
        // Add all necessary using statements
        var namespaces = commandClasses.Select(c => c.Namespace).Distinct().Where(ns => !string.IsNullOrEmpty(ns));
        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }
        
        sb.AppendLine();
        sb.AppendLine("namespace Sencilla.Messaging;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated extension methods for IMessageDispatcher.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class MessageDispatcherExtensions");
        sb.AppendLine("{");

        foreach (var commandClass in commandClasses)
        {
            GenerateExtensionMethod(sb, commandClass);
        }

        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private void GenerateExtensionMethod(StringBuilder sb, CommandClassInfo commandInfo)
    {
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Sends a {commandInfo.ClassName} command.");
        sb.AppendLine($"    /// </summary>");
        
        // Sort properties: required parameters first, then optional ones with valid defaults
        var requiredProperties = commandInfo.Properties.Where(p => p.IsRequired || (!p.HasDefaultValue || !IsValidOrStringEmptyDefault(p.DefaultValue!, p.Type))).ToList();
        var optionalProperties = commandInfo.Properties.Where(p => !p.IsRequired && p.HasDefaultValue && IsValidOrStringEmptyDefault(p.DefaultValue!, p.Type)).ToList();
        
        // Generate parameter documentation
        foreach (var prop in requiredProperties.Concat(optionalProperties))
        {
            sb.AppendLine($"    /// <param name=\"{prop.ParameterName}\">The {prop.Name} value.</param>");
        }
        sb.AppendLine($"    /// <param name=\"cancellationToken\">The cancellation token.</param>");
        sb.AppendLine($"    /// <returns>A task representing the asynchronous operation.</returns>");
        
        // Generate method signature
        sb.Append($"    public static Task {commandInfo.MethodName}(this IMessageDispatcher dispatcher");
        
        // Add required parameters first
        foreach (var prop in requiredProperties)
        {
            sb.Append($", {prop.Type} {prop.ParameterName}");
        }
        
        // Add optional parameters with valid compile-time constant defaults
        foreach (var prop in optionalProperties)
        {
            var defaultValue = GetValidDefaultForParameter(prop.DefaultValue!, prop.Type);
            var parameterType = prop.Type;
            
            // For string.Empty, make the parameter nullable with null default
            if (prop.DefaultValue == "string.Empty" && prop.Type == "string")
            {
                parameterType = "string?";
                defaultValue = "null";
            }
            
            sb.Append($", {parameterType} {prop.ParameterName} = {defaultValue}");
        }
        
        sb.AppendLine(", CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        
        // Generate method body
        sb.AppendLine($"        return dispatcher.Send(new {commandInfo.ClassName}");
        sb.AppendLine("        {");
        
        foreach (var prop in commandInfo.Properties)
        {
            if (prop.HasDefaultValue && !prop.IsRequired && !IsValidOrStringEmptyDefault(prop.DefaultValue!, prop.Type))
            {
                // For properties with non-compile-time-constant defaults, use the original default in object initialization
                sb.AppendLine($"            {prop.Name} = {prop.DefaultValue},");
            }
            else if (prop.DefaultValue == "string.Empty" && prop.Type == "string" && !prop.IsRequired)
            {
                // Handle string.Empty specially - use parameter value or string.Empty if null
                sb.AppendLine($"            {prop.Name} = {prop.ParameterName} ?? string.Empty,");
            }
            else
            {
                sb.AppendLine($"            {prop.Name} = {prop.ParameterName},");
            }
        }
        
        sb.AppendLine("        }, cancellationToken);");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static bool IsValidOrStringEmptyDefault(string defaultValue, string type)
    {
        // string.Empty is now considered valid for optional parameters
        if (defaultValue == "string.Empty" && type == "string")
        {
            return true;
        }
        
        return IsValidDefault(defaultValue, type);
    }

    private static string GetValidDefaultForParameter(string defaultValue, string type)
    {
        // For string.Empty, we'll use null as the parameter default
        if (defaultValue == "string.Empty" && type == "string")
        {
            return "null";
        }
        
        return GetValidDefault(defaultValue, type);
    }

    private static bool IsValidDefault(string defaultValue, string type)
    {
        // Only allow simple compile-time constants as defaults
        if (defaultValue == "null" || 
            defaultValue == "true" || 
            defaultValue == "false" || 
            defaultValue == "default" ||
            int.TryParse(defaultValue, out _) ||
            double.TryParse(defaultValue, out _) ||
            (defaultValue.StartsWith("\"") && defaultValue.EndsWith("\"")))
        {
            return true;
        }
        
        // string.Empty is NOT a compile-time constant
        if (defaultValue.Contains("string.Empty") ||
            defaultValue.Contains("DateTime.Now") ||
            defaultValue.Contains("DateTime.UtcNow") ||
            defaultValue.Contains("Guid.NewGuid") ||
            defaultValue.Contains("new ") ||
            defaultValue.Contains(".") ||  // Most property/method access is not compile-time constant
            defaultValue.Contains("("))     // Method calls are not compile-time constant
        {
            return false;
        }
        
        return false; // Be conservative - assume it's NOT a constant unless we explicitly know it is
    }

    private static string GetValidDefault(string defaultValue, string type)
    {
        if (IsValidDefault(defaultValue, type))
        {
            return defaultValue;
        }

        // For invalid defaults, return appropriate compile-time constants
        if (type == "string")
        {
            return "null";
        }
        else if (type == "bool")
        {
            return "false";
        }
        else if (type.Contains("int") || type.Contains("double") || type.Contains("float") || type.Contains("decimal"))
        {
            return "0";
        }
        else if (type == "DateTime")
        {
            return "default";
        }
        else
        {
            return "default";
        }
    }

    private static string ToCamelCase(string input)
    {
        if (string.IsNullOrEmpty(input) || char.IsLower(input[0]))
            return input;

        return char.ToLowerInvariant(input[0]) + input.Substring(1);
    }
}

