# Sencilla.Messaging.SourceGenerator - Usage Example

## Package Installation

```xml
<PackageReference Include="Sencilla.Messaging.SourceGenerator" Version="9.0.0" >
  <PrivateAssets>all</PrivateAssets>
  <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
</PackageReference>
```

## Example Usage

```csharp
using Sencilla.Messaging;
using Sencilla.Messaging.Extensions; // Generated namespace

// 1. Define your command classes with the attribute
[ExtendDispatcher(Method = "ProcessImage")]
public class ProcessImageCommand
{
    public required int ImageId { get; set; }
    public required string TargetPath { get; set; }
    public string ProcessingType { get; set; } = "Standard";
    public bool HighPriority { get; set; } = false;
}

[ExtendDispatcher]
public class SendNotification
{
    public required string To { get; set; }
    public required string Subject { get; set; }
    public required string Body { get; set; }
    public DateTime? ScheduledTime { get; set; }
}

// 2. Implement IMessageDispatcher (or use your existing implementation)
public class MyMessageDispatcher : IMessageDispatcher
{
    public Task Send(object message, CancellationToken cancellationToken = default)
    {
        // Your message handling logic here
        Console.WriteLine($"Processing: {message.GetType().Name}");
        return Task.CompletedTask;
    }
}

// 3. Use the generated extension methods
public class MessageService
{
    private readonly IMessageDispatcher _dispatcher;

    public MessageService(IMessageDispatcher dispatcher)
    {
        _dispatcher = dispatcher;
    }

    public async Task ProcessImageAsync(int imageId, string targetPath)
    {
        // Generated extension method
        await _dispatcher.ProcessImage(
            imageId: imageId, 
            targetPath: targetPath
        );
        
        // With optional parameters
        await _dispatcher.ProcessImage(
            imageId: imageId, 
            targetPath: targetPath,
            processingType: "Enhanced",
            highPriority: true
        );
    }

    public async Task SendNotificationAsync()
    {
        // Generated extension method  
        await _dispatcher.SendNotification(
            to: "user@example.com",
            subject: "Test",
            body: "Hello World!"
        );
    }
}
```

## What Gets Generated

The source generator will create a file like this:

```csharp
// <auto-generated />
using System;
using System.Threading;
using System.Threading.Tasks;

namespace Sencilla.Messaging.Extensions
{
    public static class MessageDispatcherExtensions
    {
        public static Task ProcessImage(
            this IMessageDispatcher dispatcher, 
            int imageId, 
            string targetPath, 
            string processingType = "Standard", 
            bool highPriority = false, 
            CancellationToken cancellationToken = default)
        {
            return dispatcher.Send(new ProcessImageCommand
            {
                ImageId = imageId,
                TargetPath = targetPath,
                ProcessingType = processingType,
                HighPriority = highPriority
            }, cancellationToken);
        }

        public static Task SendNotification(
            this IMessageDispatcher dispatcher, 
            string to, 
            string subject, 
            string body, 
            DateTime? scheduledTime = default, 
            CancellationToken cancellationToken = default)
        {
            return dispatcher.Send(new SendNotification
            {
                To = to,
                Subject = subject,
                Body = body,
                ScheduledTime = scheduledTime
            }, cancellationToken);
        }
    }
}
```

## Benefits

1. **Type Safety**: Compile-time checking of parameters
2. **IntelliSense**: Full IDE support with parameter hints
3. **Less Boilerplate**: No need to manually create command objects
4. **Maintainable**: Extension methods are automatically updated when commands change
5. **Performance**: No reflection or runtime overhead
